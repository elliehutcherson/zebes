#include "editor/texture_editor.h"

#include "ImGuiFileDialog.h"
#include "SDL_render.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "common/common.h"
#include "imgui.h"

namespace zebes {

absl::StatusOr<std::unique_ptr<TextureEditor>> TextureEditor::Create(Api* api, SdlWrapper* sdl) {
  if (api == nullptr) {
    return absl::InvalidArgumentError("Api must not be null");
  }
  if (sdl == nullptr) {
    return absl::InvalidArgumentError("SdlWrapper must not be null");
  }
  return std::unique_ptr<TextureEditor>(new TextureEditor(api, sdl));
}

TextureEditor::TextureEditor(Api* api, SdlWrapper* sdl) : api_(api), sdl_(sdl) {
  RefreshTextures();
}

TextureEditor::~TextureEditor() {
  if (selected_texture_.sdl_texture != nullptr) {
    sdl_->DestroyTexture(reinterpret_cast<SDL_Texture*>(selected_texture_.sdl_texture));
  }
}

void TextureEditor::RefreshTextures() {
  auto result = api_->GetAllTextures();
  if (!result.ok()) {
    LOG(ERROR) << "Failed to fetch textures for importer: " << result.status();
    texture_list_.clear();
  }

  texture_list_ = *result;
  std::sort(texture_list_.begin(), texture_list_.end(),
            [](const Texture& a, const Texture& b) { return a.name < b.name; });
}

void TextureEditor::LoadPreview(const std::string& path) {
  if (!selected_texture_.id.empty()) return;

  if (selected_texture_.sdl_texture != nullptr) {
    sdl_->DestroyTexture(reinterpret_cast<SDL_Texture*>(selected_texture_.sdl_texture));
    selected_texture_.sdl_texture = nullptr;
  }

  absl::StatusOr<SDL_Texture*> texture = sdl_->CreateTexture(path);
  if (!texture.ok()) {
    LOG(ERROR) << "Failed to load preview for importer: " << texture.status();
    return;
  }

  selected_texture_.sdl_texture = *texture;
}

void TextureEditor::SelectTexture(const Texture& texture) {
  selected_texture_ = texture;
  new_texture_ = false;
  edit_name_buffer_ = texture.name;
  // +1 for null terminator
  if (edit_name_buffer_.size() <= kMaxTextureNameLength) {
    edit_name_buffer_.resize(kMaxTextureNameLength + 1, '\0');
  }
}

void TextureEditor::Render() {
  // Use tables for list and inspector
  if (ImGui::BeginTable(
          "TextureEditorTable", 2,
          ImGuiTableFlags_Resizable | ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg)) {
    ImGui::TableSetupColumn("Texture List", ImGuiTableColumnFlags_WidthStretch);
    ImGui::TableSetupColumn("Details", ImGuiTableColumnFlags_WidthStretch);

    ImGui::TableNextRow();
    ImGui::TableNextColumn();

    // Column 1: Texture List
    RenderTextureList();

    ImGui::TableNextColumn();

    // Column 2: Details
    RenderTextureDetails();

    ImGui::EndTable();
  }

  // Handle File Dialog
  if (ImGuiFileDialog::Instance()->Display("TextureOpenDlg_v2")) {
    if (ImGuiFileDialog::Instance()->IsOk()) {
      std::string filePathName = ImGuiFileDialog::Instance()->GetFilePathName();
      selected_texture_.path = filePathName;
      LoadPreview(selected_texture_.path);
    }
    ImGuiFileDialog::Instance()->Close();
  }

  ImGui::Separator();

  // Preview below the table
  RenderPreview();
}

void TextureEditor::RenderTextureList() {
  ImGui::Text("Imported Textures");

  // Refresh list if empty (or add a refresh button)
  if (texture_list_.empty()) {
    if (ImGui::Button("Refresh List")) {
      RefreshTextures();
    }
  } else {
    if (ImGui::Button("Refresh List")) {
      RefreshTextures();
    }
  }

  ImGui::SameLine();
  if (ImGui::Button("New Texture")) {
    new_texture_ = true;
    selected_texture_ = {};
    selected_texture_ = {};
    edit_name_buffer_ = "";
    edit_name_buffer_.resize(kMaxTextureNameLength + 1, '\0');
  }

  // List textures
  if (ImGui::BeginListBox("##Textures",
                          ImVec2(-FLT_MIN, 10 * ImGui::GetTextLineHeightWithSpacing()))) {
    for (const Texture& texture : texture_list_) {
      bool is_selected = (!new_texture_ && selected_texture_.id == texture.id);
      std::string label = texture.name_id();
      if (ImGui::Selectable(label.c_str(), is_selected)) {
        SelectTexture(texture);
      }
      if (is_selected) {
        ImGui::SetItemDefaultFocus();
      }
    }
    ImGui::EndListBox();
  }
}

void TextureEditor::RenderTextureDetails() {
  if (selected_texture_.id.empty() && !new_texture_) {
    ImGui::TextDisabled("Select a texture to edit.");
    return;
  }

  ImGui::Text("Texture Details");
  ImGui::Separator();

  // ID Field
  if (new_texture_) {
    ImGui::Text("ID: <Auto-Generated>");
  } else {
    // Read-only for existing
    ImGui::LabelText("ID", "%s", selected_texture_.id.c_str());
  }

  // Name Field
  ImGui::InputText("Name", edit_name_buffer_.data(), edit_name_buffer_.size());

  // Path Field (Read-only for now, consistent with existing logic usually)
  ImGui::LabelText("Path", "%s", selected_texture_.path.c_str());

  if (new_texture_) {
    ImGui::SameLine();
    if (ImGui::Button("Browse...")) {
      IGFD::FileDialogConfig config;
      config.path = ".";
      ImGuiFileDialog::Instance()->OpenDialog("TextureOpenDlg_v2", "Choose File",
                                              ".png,.jpg,.jpeg,.bmp", config);
    }
  }

  ImGui::Spacing();

  if (new_texture_ && ImGui::Button("Create")) {
    // TODO: Implement Create Logic
    selected_texture_.name = edit_name_buffer_.c_str();
    // We assume selected_texture_.path is already set by the file dialog
    if (selected_texture_.path.empty()) {
      LOG(ERROR) << "Cannot create texture without a path.";
      return;
    }

    auto result = api_->CreateTexture(selected_texture_);
    if (!result.ok()) {
      LOG(ERROR) << "Failed to create texture: " << result.status();
      return;
    }

    RefreshTextures();
    new_texture_ = false;
    return;
  }

  if (ImGui::Button("Save")) {
    selected_texture_.name = edit_name_buffer_.c_str();
    auto status = api_->UpdateTexture(selected_texture_);
    if (!status.ok()) {
      LOG(ERROR) << "Failed to update texture: " << status;
      return;
    }

    RefreshTextures();
  }
}

void TextureEditor::RenderZoom() {
  // Zoom controls
  if (ImGui::Button("-")) {
    zoom_ *= 0.8f;
    if (zoom_ < 0.1f) zoom_ = 0.1f;
  }
  ImGui::SameLine();
  if (ImGui::Button("+")) {
    zoom_ *= 1.25f;
    if (zoom_ > 10.0f) zoom_ = 10.0f;
  }
  ImGui::SameLine();
  if (ImGui::Button("Reset Zoom")) {
    zoom_ = 1.0f;
  }
  ImGui::SameLine();
  ImGui::Text("Zoom: %.1fx", zoom_);

  int w = 0, h = 0;
  if (selected_texture_.sdl_texture) {
    SDL_QueryTexture(reinterpret_cast<SDL_Texture*>(selected_texture_.sdl_texture), nullptr,
                     nullptr, &w, &h);
  }
  float aspect = (h > 0) ? static_cast<float>(w) / static_cast<float>(h) : 1.0f;
  preview_w_ = 200.0f * zoom_;
  preview_h_ = preview_w_ / aspect;

  ImGui::Text("Size: %dx%d", w, h);
}

void TextureEditor::RenderPreview() {
  RenderZoom();

  ImGui::Text("Texture Preview");

  // Display the image with zoom applied
  ImGui::BeginChild("PreviewRegion", ImVec2(0, 400), true, ImGuiWindowFlags_HorizontalScrollbar);

  if (selected_texture_.sdl_texture == nullptr) {
    ImGui::TextDisabled("No texture loaded.");
    ImGui::EndChild();
    return;
  }

  // Mouse wheel zoom when hovering over preview
  if (ImGui::IsWindowHovered()) {
    float wheel = ImGui::GetIO().MouseWheel;
    if (wheel != 0.0f) {
      zoom_ *= (1.0f + wheel * 0.1f);
      if (zoom_ < 0.1f) zoom_ = 0.1f;
      if (zoom_ > 10.0f) zoom_ = 10.0f;
    }
  }

  ImGui::Image(reinterpret_cast<ImTextureID>(selected_texture_.sdl_texture),
               ImVec2(preview_w_, preview_h_));
  ImGui::EndChild();
}

}  // namespace zebes
