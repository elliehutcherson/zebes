#include "editor/level_editor/level_panel.h"

#include "absl/cleanup/cleanup.h"
#include "absl/status/status.h"
#include "common/status_macros.h"
#include "imgui.h"
#include "misc/cpp/imgui_stdlib.h"
#include "objects/level.h"

namespace zebes {

constexpr char kAutoGenerated[] = "<auto>";

absl::StatusOr<std::unique_ptr<LevelPanel>> LevelPanel::Create(Options options) {
  if (options.api == nullptr) {
    return absl::InvalidArgumentError("API can not be null.");
  }
  return absl::WrapUnique(new LevelPanel(std::move(options)));
}

LevelPanel::LevelPanel(Options options) : api_(*options.api) { RefreshLevelCache(); }

absl::StatusOr<LevelResult> LevelPanel::Render(std::optional<Level>& level) {
  ImGui::PushID("LevelPanel");
  auto cleanup = absl::MakeCleanup([] { ImGui::PopID(); });

  ImGui::Text("Levels");
  ImGui::Separator();

  if (level.has_value()) {
    return RenderDetails(level);
  }

  return RenderList(level);
}

absl::StatusOr<LevelResult> LevelPanel::RenderList(std::optional<Level>& level) {
  LevelResult result;

  if (ImGui::Button("Create")) {
    ASSIGN_OR_RETURN(result, HandleOp(level, Op::kLevelCreate));
  }
  ImGui::SameLine();

  if (ImGui::Button("Edit")) {
    ASSIGN_OR_RETURN(result, HandleOp(level, Op::kLevelEdit));
  }
  ImGui::SameLine();

  {
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
    auto cleanup = absl::MakeCleanup([] { ImGui::PopStyleColor(); });
    if (ImGui::Button("Delete")) {
      ASSIGN_OR_RETURN(result, HandleOp(level, Op::kLevelDelete));
    }
  }

  if (ImGui::BeginListBox("##Levels", ImVec2(-FLT_MIN, -FLT_MIN))) {
    for (int i = 0; i < level_cache_.size(); ++i) {
      const bool is_selected = (selected_index_ == i);
      if (ImGui::Selectable(level_cache_[i].name.c_str(), is_selected)) {
        selected_index_ = i;
      }

      // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)
      if (is_selected) ImGui::SetItemDefaultFocus();
    }
    ImGui::EndListBox();
  }

  return result;
}

absl::StatusOr<LevelResult> LevelPanel::RenderDetails(std::optional<Level>& level) {
  LevelResult result;
  // At this point we known that level is not null.
  Level& lvl = *level;

  if (ImGui::Button("Back")) {
    ASSIGN_OR_RETURN(result, HandleOp(level, Op::kLevelBack));
  }

  ImGui::SameLine();
  if (ImGui::Button("Save")) {
    ASSIGN_OR_RETURN(result, HandleOp(level, Op::kLevelSave));
  }

  ImGui::Separator();
  ImGui::Text("Details");

  ImGui::InputText("ID", &lvl.id, ImGuiInputTextFlags_ReadOnly);
  ImGui::InputText("Name", &lvl.name);
  ImGui::InputDouble("Width", &lvl.width);
  ImGui::InputDouble("Height", &lvl.height);

  ImGui::Text("Spawn Point");
  ImGui::InputDouble("X", &lvl.spawn_point.x);
  ImGui::SameLine();
  ImGui::InputDouble("Y", &lvl.spawn_point.y);

  return result;
}

absl::StatusOr<LevelResult> LevelPanel::HandleOp(std::optional<Level>& level, Op op) {
  LevelResult result;

  if (op == Op::kLevelEdit || op == Op::kLevelDelete) {
    if (level.has_value()) {
      return absl::InvalidArgumentError("Level must be null!");
    }
    if (selected_index_ < 0) {
      LOG(INFO) << "No level selected, not deleting...";
      return result;
    }
    if (selected_index_ >= level_cache_.size()) {
      return absl::InternalError("Selected index outside of range!!!");
    }
  }

  switch (op) {
    case Op::kLevelCreate: {
      ++counters_.create;
      level = Level{.id = kAutoGenerated, .name = "name"};
      ASSIGN_OR_RETURN(std::string id, api_.CreateLevel(*level));
      level->id = id;
      level_cache_.push_back(*level);
      result.type = LevelResult::kChanged;
      break;
    }
    case Op::kLevelEdit:
      ++counters_.edit;
      level = level_cache_[selected_index_];
      result.type = LevelResult::kChanged;
      break;
    case Op::kLevelSave:
      ++counters_.save;
      if (!level.has_value()) {
        return absl::InvalidArgumentError("Level must not be null!");
      }
      RETURN_IF_ERROR(api_.UpdateLevel(*level));
      RefreshLevelCache();
      result.type = LevelResult::kChanged;
      break;
    case Op::kLevelDelete:
      ++counters_.del;
      RETURN_IF_ERROR(api_.DeleteLevel(level_cache_[selected_index_].id));
      RefreshLevelCache();
      result.type = LevelResult::kChanged;
      break;
    case Op::kLevelBack:
      ++counters_.back;
      level.reset();
      result.type = LevelResult::kChanged;
      break;
  }

  return result;
}

void LevelPanel::RefreshLevelCache() {
  level_cache_ = api_.GetAllLevels();

  std::sort(level_cache_.begin(), level_cache_.end(),
            [](const Level& a, const Level& b) { return a.name < b.name; });

  LOG(INFO) << "Loaded " << level_cache_.size() << " levels.";
}

}  // namespace zebes
