#include "editor/level_editor/level_panel.h"

#include <memory>

#include "absl/cleanup/cleanup.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/strings/str_cat.h"
#include "common/status_macros.h"
#include "editor/editor_utils.h"
#include "imgui.h"
#include "misc/cpp/imgui_stdlib.h"
#include "objects/level.h"

namespace zebes {

constexpr char kAutoGenerated[] = "<auto>";

absl::StatusOr<std::unique_ptr<LevelPanel>> LevelPanel::Create(Api* api) {
  if (api == nullptr) {
    return absl::InvalidArgumentError("API can not be null.");
  }
  return absl::WrapUnique(new LevelPanel(api));
}

LevelPanel::LevelPanel(Api* api) : api_(*api) { RefreshLevelCache(); }

void LevelPanel::Detach() {
  selected_index_ = -1;
  editting_level_.reset();
}

absl::Status LevelPanel::Attach(int i) {
  if (i < 0 || i >= level_cache_.size()) {
    return absl::OutOfRangeError("Level not found!!!");
  }

  selected_index_ = -1;
  editting_level_ = level_cache_[i].GetCopy();
  return absl::OkStatus();
}

absl::Status LevelPanel::Attach(const std::string& id) {
  ASSIGN_OR_RETURN(Level * level, api_.GetLevel(id));

  selected_index_ = -1;
  editting_level_ = level->GetCopy();
  return absl::OkStatus();
}

void LevelPanel::RefreshLevelCache() {
  level_cache_ = api_.GetAllLevels();

  std::sort(level_cache_.begin(), level_cache_.end(),
            [](const Level& a, const Level& b) { return a.name < b.name; });

  LOG(INFO) << "Loaded " << level_cache_.size() << " levels.";
}

absl::StatusOr<LevelResult> LevelPanel::Render() {
  ImGui::PushID("LevelPanel");
  auto cleanup = absl::MakeCleanup([] { ImGui::PopID(); });

  ImGui::Text("Level");
  ImGui::Separator();

  if (editting_level_.has_value()) {
    return RenderDetails();
  }

  return RenderList();
}

absl::StatusOr<LevelResult> LevelPanel::RenderList() {
  counters_.render_list_count++;
  LevelResult result;

  if (ImGui::Button("Create")) {
    editting_level_ = {
        .id = kAutoGenerated,
        .name = "New Level",
    };
    RETURN_IF_ERROR(ConfirmState(Op::kLevelCreate));
    result = {LevelResult::Type::kAttach, editting_level_->id};
  }
  ImGui::SameLine();

  if (ImGui::Button("Attach") && selected_index_ > -1) {
    RETURN_IF_ERROR(Attach(selected_index_));
    result = {LevelResult::Type::kAttach, editting_level_->id};
  }
  ImGui::SameLine();

  ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
  if (ImGui::Button("Delete") && selected_index_ > -1) {
    RETURN_IF_ERROR(ConfirmState(Op::kLevelDelete));
    Detach();
  }
  ImGui::PopStyleColor();

  // List Box
  if (ImGui::BeginListBox("Levels", ImVec2(-FLT_MIN, -FLT_MIN))) {
    for (int i = 0; i < level_cache_.size(); ++i) {
      const bool is_selected = (selected_index_ == i);
      const Level& level = level_cache_[i];

      if (ImGui::Selectable(level.name_id().c_str(), is_selected)) selected_index_ = i;

      // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)
      if (is_selected) ImGui::SetItemDefaultFocus();
    }
    ImGui::EndListBox();
  }

  return result;
}

absl::StatusOr<LevelResult> LevelPanel::RenderDetails() {
  counters_.render_details_count++;
  LevelResult result;

  // Header information
  ImGui::Text("ID: %s", editting_level_->id.c_str());
  ImGui::InputText("Name", &editting_level_->name);

  // Save and Reset Buttons
  ImGui::Separator();

  // We always have Save, Reset, and Detach.
  // Calculate width based on available space and spacing.
  float button_width = CalculateButtonWidth(/*num_buttons=*/3);

  // Save Button
  if (ImGui::Button("Save", ImVec2(button_width, 0))) {
    RETURN_IF_ERROR(ConfirmState(Op::kLevelUpdate));
  }
  ImGui::SameLine();

  // Detach Button (Orange)
  ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.4f, 0.0f, 1.0f));
  if (ImGui::Button("Detach", ImVec2(button_width, 0))) {
    Detach();
    result = {LevelResult::Type::kDetach};
  }
  ImGui::PopStyleColor();
  ImGui::SameLine();

  // Reset Button (Red)
  ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
  if (ImGui::Button("Reset", ImVec2(button_width, 0))) {
    RETURN_IF_ERROR(ConfirmState(Op::kLevelReset));
  }
  ImGui::PopStyleColor();

  return result;
}

absl::Status LevelPanel::ConfirmState(Op op) {
  if (!editting_level_.has_value()) {
    return absl::InternalError("Level is null!!!");
  }

  if (op == Op::kLevelDelete) {
    RETURN_IF_ERROR(api_.DeleteLevel(editting_level_->id));
  }

  if (op == Op::kLevelUpdate) {
    RETURN_IF_ERROR(api_.UpdateLevel(editting_level_->GetCopy()));
  }

  if (op == Op::kLevelCreate) {
    editting_level_ = {
        .id = kAutoGenerated,
        .name = absl::StrCat("level_", level_cache_.size()),
    };
    ASSIGN_OR_RETURN(std::string id, api_.CreateLevel(editting_level_->GetCopy()));
    editting_level_->id = id;
  }

  if (op == Op::kLevelReset) {
    if (editting_level_->id == kAutoGenerated) {
      editting_level_ = {
          .id = kAutoGenerated,
          .name = absl::StrCat("level_", level_cache_.size()),
      };
    } else {
      RETURN_IF_ERROR(Attach(editting_level_->id));
    }
  }

  RefreshLevelCache();

  return absl::OkStatus();
}

}  // namespace zebes