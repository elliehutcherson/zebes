#include "editor/blueprint_editor/blueprint_panel.h"

#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "editor/editor_utils.h"
#include "editor/gui_interface.h"
#include "editor/imgui_scoped.h"
#include "imgui.h"
#include "objects/blueprint.h"

namespace zebes {

constexpr char kAutoGenerated[] = "<auto>";

absl::StatusOr<std::unique_ptr<BlueprintPanel>> BlueprintPanel::Create(Api* api,
                                                                       GuiInterface* gui) {
  if (api == nullptr) {
    return absl::InvalidArgumentError("API can not be null.");
  }
  if (gui == nullptr) {
    return absl::InvalidArgumentError("GUI can not be null.");
  }
  return absl::WrapUnique(new BlueprintPanel(api, gui));
}

BlueprintPanel::BlueprintPanel(Api* api, GuiInterface* gui) : api_(api), gui_(gui) {
  RefreshBlueprintCache();
}

void BlueprintPanel::RefreshBlueprintCache() {
  blueprint_cache_ = api_->GetAllBlueprints();

  std::sort(blueprint_cache_.begin(), blueprint_cache_.end(),
            [](const Blueprint& a, const Blueprint& b) { return a.name < b.name; });

  LOG(INFO) << "Loaded " << blueprint_cache_.size() << " blueprints.";
}

int BlueprintPanel::Render() {
  if (mode_ == kBlueprintPanelList) {
    RenderList();
    // If in list mode, we are not editting a state.
    return -1;
  }

  if (mode_ == kBlueprintPanelNew || mode_ == kBlueprintPanelEdit) {
    return RenderDetails();
  }

  LOG(ERROR) << __func__ << ": Unrecognized mode!!!!";
  return -1;
}

void BlueprintPanel::RenderList() {
  // CRUD Buttons
  if (gui_->Button("Create")) {
    mode_ = kBlueprintPanelNew;
    editting_blueprint_ = {
        .id = kAutoGenerated,
        .name = "New Blueprint",
    };
  }
  gui_->SameLine();

  if (gui_->Button("Edit") && blueprint_index_ > -1) {
    mode_ = kBlueprintPanelEdit;
    editting_blueprint_ = blueprint_cache_[blueprint_index_];
  }

  gui_->SameLine();
  {
    ScopedStyleColor style =
        gui_->CreateScopedStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
    if (gui_->Button("Delete") && blueprint_index_ > -1) {
      mode_ = kBlueprintPanelList;
      editting_blueprint_ = blueprint_cache_[blueprint_index_];
      ConfirmState(Op::kBlueprintDelete);
      blueprint_index_ = -1;
      editting_blueprint_.reset();
    }
  }

  // List Box
  if (auto list_box = gui_->CreateScopedListBox("Blueprints", ImVec2(-FLT_MIN, -FLT_MIN));
      list_box) {
    for (int i = 0; i < blueprint_cache_.size(); ++i) {
      const bool is_selected = (blueprint_index_ == i);
      if (gui_->Selectable(blueprint_cache_[i].name_id().c_str(), is_selected)) {
        blueprint_index_ = i;
      }

      // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)
      if (is_selected) ImGui::SetItemDefaultFocus();
    }
  }
}

int BlueprintPanel::RenderDetails() {
  if (gui_->Button("Back")) {
    mode_ = kBlueprintPanelList;
    return -1;
  }

  // Header information
  if (editting_blueprint_.has_value()) {
    gui_->Text("ID: %s", editting_blueprint_->id.c_str());
    gui_->InputText("Name", &editting_blueprint_->name);
  }

  int state_index = RenderStateList();

  // Button for editting states
  gui_->Separator();

  float button_width = CalculateButtonWidth(/*num_buttons=*/1);
  if (gui_->Button("Save", ImVec2(button_width, 0))) {
    Op op = mode_ == kBlueprintPanelEdit ? Op::kBlueprintUpdate : Op::kBlueprintCreate;
    ConfirmState(op);
  }

  return state_index;
}

int BlueprintPanel::RenderStateList() {
  gui_->Separator();
  gui_->Text("States");
  gui_->SameLine();
  if (gui_->Button("Add State")) {
    editting_blueprint_->states.push_back({.name = "new state"});
  }

  if (!editting_blueprint_.has_value()) return -1;

  int i = 0;
  int selected_index = -1;
  std::erase_if(editting_blueprint_->states, [&](const Blueprint::State& state) -> bool {
    ScopedId id = gui_->CreateScopedId(i);
    bool deleted = RenderStateDetails(state.name, i, &selected_index);

    ++i;
    return deleted;
  });
  return selected_index;
}

// Returns true if deleted.
bool BlueprintPanel::RenderStateDetails(const std::string& name, int index, int* selected_index) {
  gui_->Text("%s", name.c_str());
  gui_->SameLine();
  if (gui_->Button("Edit")) {
    *selected_index = index;
  }
  gui_->SameLine();
  // X button next to label
  return gui_->Button("X");
}

void BlueprintPanel::ConfirmState(Op op) {
  if (!editting_blueprint_.has_value()) {
    return;
  }

  if (op == Op::kBlueprintDelete) {
    absl::Status result = api_->DeleteBlueprint(editting_blueprint_->id);
    if (result.ok()) {
      LOG(INFO) << "Successfully delete blueprint: " << editting_blueprint_->name << ", "
                << editting_blueprint_->id;
    } else {
      LOG(ERROR) << "Failed to delete blueprint: " << editting_blueprint_->name << ", "
                 << editting_blueprint_->id;
    }
  }

  if (op == Op::kBlueprintUpdate) {
    absl::Status status = api_->UpdateBlueprint(*editting_blueprint_);
    if (status.ok()) {
      LOG(INFO) << "Saved blueprint: " << editting_blueprint_->name;
    } else {
      LOG(ERROR) << "Failed to save: " << status.message();
    }
  }

  if (op == Op::kBlueprintCreate) {
    absl::StatusOr<std::string> id = api_->CreateBlueprint(*editting_blueprint_);
    if (id.ok()) {
      editting_blueprint_->id = *id;
      LOG(INFO) << "Saved blueprint: " << editting_blueprint_->name;
      RefreshBlueprintCache();
    } else {
      LOG(ERROR) << "Failed to save: " << id.status();
    }
  }

  RefreshBlueprintCache();
}

Blueprint* BlueprintPanel::GetBlueprint() {
  if (!editting_blueprint_.has_value()) return nullptr;
  return &*editting_blueprint_;
}

}  // namespace zebes