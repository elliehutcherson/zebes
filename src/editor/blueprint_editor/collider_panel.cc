#include "editor/blueprint_editor/collider_panel.h"

#include <memory>

#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/strings/str_cat.h"
#include "common/status_macros.h"
#include "editor/canvas/canvas_collider.h"
#include "editor/editor_utils.h"
#include "editor/gui_interface.h"
#include "editor/imgui_scoped.h"
#include "imgui.h"
#include "misc/cpp/imgui_stdlib.h"
#include "objects/collider.h"

namespace zebes {

constexpr char kAutoGenerated[] = "<auto>";

absl::StatusOr<std::unique_ptr<ColliderPanel>> ColliderPanel::Create(Api* api, GuiInterface* gui) {
  if (api == nullptr) {
    return absl::InvalidArgumentError("API can not be null.");
  }
  if (gui == nullptr) {
    return absl::InvalidArgumentError("GUI can not be null.");
  }
  return absl::WrapUnique(new ColliderPanel(api, gui));
}

ColliderPanel::ColliderPanel(Api* api, GuiInterface* gui) : api_(*api), gui_(gui) {
  RefreshColliderCache();
}

void ColliderPanel::Detach() {
  selected_index_ = -1;
  editting_collider_.reset();
  canvas_collider_.reset();
}

absl::Status ColliderPanel::Attach(int i) {
  if (i < 0 || i >= collider_cache_.size()) {
    return absl::OutOfRangeError("Collider not found!!!");
  }

  selected_index_ = -1;
  editting_collider_ = collider_cache_[i];
  canvas_collider_ = std::make_unique<CanvasCollider>(*editting_collider_);
  return absl::OkStatus();
}

absl::Status ColliderPanel::Attach(const std::string& id) {
  ASSIGN_OR_RETURN(Collider * collider, api_.GetCollider(id));

  selected_index_ = -1;
  editting_collider_ = *collider;
  canvas_collider_ = std::make_unique<CanvasCollider>(*editting_collider_);
  return absl::OkStatus();
}

void ColliderPanel::RefreshColliderCache() {
  collider_cache_ = api_.GetAllColliders();

  std::sort(collider_cache_.begin(), collider_cache_.end(),
            [](const Collider& a, const Collider& b) { return a.name < b.name; });

  LOG(INFO) << "Loaded " << collider_cache_.size() << " colliders.";
}

absl::StatusOr<ColliderResult> ColliderPanel::Render() {
  ScopedId id(gui_, "ColliderPanel");

  gui_->Text("Collider");
  gui_->Separator();

  if (editting_collider_.has_value()) {
    return RenderDetails();
  }

  return RenderList();
}

absl::StatusOr<ColliderResult> ColliderPanel::RenderList() {
  ColliderResult result;

  if (gui_->Button("Create")) {
    RETURN_IF_ERROR(ConfirmState(Op::kColliderCreate));
    result = {ColliderResult::Type::kAttach, editting_collider_->id};
  }
  gui_->SameLine();

  if (gui_->Button("Attach") && selected_index_ > -1) {
    RETURN_IF_ERROR(Attach(selected_index_));
    result = {ColliderResult::Type::kAttach, editting_collider_->id};
  }
  gui_->SameLine();

  {
    ScopedStyleColor style(gui_, ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
    if (gui_->Button("Delete") && selected_index_ > -1) {
      RETURN_IF_ERROR(ConfirmState(Op::kColliderDelete));
      Detach();
    }
  }

  // List Box
  if (ScopedListBox list_box(gui_, "Colliders", ImVec2(-FLT_MIN, -FLT_MIN)); list_box) {
    for (int i = 0; i < collider_cache_.size(); ++i) {
      const bool is_selected = (selected_index_ == i);
      const Collider& collider = collider_cache_[i];

      if (gui_->Selectable(collider.name_id().c_str(), is_selected)) selected_index_ = i;

      // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)
      if (is_selected) ImGui::SetItemDefaultFocus();
    }
  }

  return result;
}

absl::StatusOr<ColliderResult> ColliderPanel::RenderDetails() {
  ColliderResult result;

  // Header information
  gui_->Text("ID: %s", editting_collider_->id.c_str());
  gui_->InputText("Name", &editting_collider_->name);

  RenderPolygonList();

  // Save and Reset Buttons
  gui_->Separator();

  // We always have Save, Reset, and Detach.
  // Calculate width based on available space and spacing.
  float button_width = CalculateButtonWidth(/*num_buttons=*/3);

  // Save Button
  if (gui_->Button("Save", ImVec2(button_width, 0))) {
    RETURN_IF_ERROR(ConfirmState(Op::kColliderUpdate));
  }
  gui_->SameLine();

  // Detach Button (Orange)
  {
    ScopedStyleColor style(gui_, ImGuiCol_Button, ImVec4(0.8f, 0.4f, 0.0f, 1.0f));
    if (gui_->Button("Detach", ImVec2(button_width, 0))) {
      Detach();
      result = {ColliderResult::Type::kDetach};
    }
  }
  gui_->SameLine();

  // Reset Button (Red)
  {
    ScopedStyleColor style(gui_, ImGuiCol_Button, ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
    if (gui_->Button("Reset", ImVec2(button_width, 0))) {
      RETURN_IF_ERROR(ConfirmState(Op::kColliderReset));
    }
  }

  return result;
}

void ColliderPanel::RenderPolygonList() {
  gui_->Separator();
  gui_->Text("Polygons");
  gui_->SameLine();
  if (gui_->Button("Add Polygon")) {
    Polygon poly;
    poly.push_back({0, 0});
    poly.push_back({50, 0});
    poly.push_back({50, 50});
    poly.push_back({0, 50});
    editting_collider_->polygons.push_back(poly);
  }

  int i = 0;
  std::erase_if(editting_collider_->polygons, [&](Polygon& p) -> bool {
    ScopedId id(gui_, i);
    bool deleted = RenderPolygonDetails(p, i);

    ++i;
    return deleted;
  });
}

bool ColliderPanel::RenderPolygonDetails(Polygon& poly, int index) {
  gui_->Text("Polygon %d", index);
  gui_->SameLine();
  // X button next to label
  if (gui_->Button("X")) {
    return true;
  }

  // Vertices
  int i = 0;
  std::erase_if(poly, [&i, this](Vec& v) -> bool {
    bool deleted = false;
    ScopedId id(gui_, i);
    ++i;
    // For each vertex we should be able to edit x and y.
    gui_->SetNextItemWidth(100);
    gui_->InputDouble("##vec_x", &v.x);
    gui_->SameLine();
    gui_->SetNextItemWidth(100);
    gui_->InputDouble("##vec_y", &v.y);
    gui_->SameLine();
    if (gui_->Button("X", ImVec2(30, 0))) {
      deleted = true;
    }

    return deleted;
  });

  if (gui_->Button("Add Vertex")) {
    poly.push_back({0, 0});
  }

  return false;
}

absl::StatusOr<bool> ColliderPanel::RenderCanvas(Canvas& canvas, bool input_allowed) {
  if (!editting_collider_.has_value()) return false;

  return canvas_collider_->Render(canvas, input_allowed);
}

absl::Status ColliderPanel::ConfirmState(Op op) {
  if (!editting_collider_.has_value()) {
    return absl::InternalError("Collider is null!!!");
  }

  if (op == Op::kColliderDelete) {
    RETURN_IF_ERROR(api_.DeleteCollider(editting_collider_->id));
  }

  if (op == Op::kColliderUpdate) {
    RETURN_IF_ERROR(api_.UpdateCollider(*editting_collider_));
  }

  if (op == Op::kColliderCreate) {
    editting_collider_ = {
        .id = kAutoGenerated,
        .name = absl::StrCat("collider_", collider_cache_.size()),
    };
    ASSIGN_OR_RETURN(std::string id, api_.CreateCollider(*editting_collider_));
    editting_collider_->id = id;
  }

  if (op == Op::kColliderReset) {
    if (editting_collider_->id == kAutoGenerated) {
      editting_collider_ = {
          .id = kAutoGenerated,
          .name = absl::StrCat("collider_", collider_cache_.size()),
      };
    } else {
      RETURN_IF_ERROR(Attach(editting_collider_->id));
    }
  }

  RefreshColliderCache();

  return absl::OkStatus();
}

}  // namespace zebes