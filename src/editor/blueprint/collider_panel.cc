#include "editor/blueprint/collider_panel.h"

#include <memory>

#include "absl/cleanup/cleanup.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/strings/str_cat.h"
#include "editor/canvas_collider.h"
#include "editor/editor_utils.h"
#include "imgui.h"
#include "misc/cpp/imgui_stdlib.h"
#include "objects/collider.h"

namespace zebes {

constexpr char kAutoGenerated[] = "<auto>";

absl::StatusOr<std::unique_ptr<ColliderPanel>> ColliderPanel::Create(Api* api) {
  if (api == nullptr) {
    return absl::InvalidArgumentError("API can not be null.");
  }
  return absl::WrapUnique(new ColliderPanel(api));
}

ColliderPanel::ColliderPanel(Api* api) : api_(api) { RefreshColliderCache(); }

void ColliderPanel::Clear() {
  collider_index_ = -1;
  attached_id_.reset();
  editting_collider_.reset();
  canvas_collider_.reset();
  mode_ = kColliderPanelList;
}

void ColliderPanel::RefreshColliderCache() {
  collider_cache_ = api_->GetAllColliders();

  std::sort(collider_cache_.begin(), collider_cache_.end(),
            [](const Collider& a, const Collider& b) { return a.name < b.name; });

  LOG(INFO) << "Loaded " << collider_cache_.size() << " colliders.";
}

void ColliderPanel::SetCollider(const std::string& id) {
  for (int i = 0; i < collider_cache_.size(); ++i) {
    if (collider_cache_[i].id != id) continue;

    collider_index_ = i;
    editting_collider_ = collider_cache_[i];
    attached_id_ = id;
    mode_ = Mode::kColliderPanelEdit;
    canvas_collider_ = std::make_unique<CanvasCollider>(*editting_collider_);
    return;
  }

  LOG(WARNING) << "Collider not found: " << id;
}

ColliderResult ColliderPanel::Render() {
  ImGui::PushID("ColliderPanel");
  auto cleanup = absl::MakeCleanup([] { ImGui::PopID(); });

  ImGui::Text("Collider");
  ImGui::Separator();

  if (mode_ == Mode::kColliderPanelList) {
    return RenderList();
  }

  if (mode_ == Mode::kColliderPanelNew || mode_ == Mode::kColliderPanelEdit) {
    return RenderDetails();
  }

  LOG(ERROR) << __func__ << ": Unrecognized mode!!!!";
  return {};
}

ColliderResult ColliderPanel::RenderList() {
  ColliderResult result;

  // CRUD Buttons
  if (ImGui::Button("Create")) {
    editting_collider_ = {
        .id = kAutoGenerated,
        .name = absl::StrCat("collider_", collider_cache_.size()),
    };
    mode_ = Mode::kColliderPanelEdit;
    ConfirmState(Op::kColliderCreate);
    attached_id_ = editting_collider_->id;
    result = {ColliderResult::Type::kAttach, attached_id_.value()};
  }
  ImGui::SameLine();

  if (ImGui::Button("Attach") && collider_index_ > -1) {
    mode_ = Mode::kColliderPanelEdit;
    editting_collider_ = collider_cache_[collider_index_];
    attached_id_ = editting_collider_->id;
    canvas_collider_ = std::make_unique<CanvasCollider>(*editting_collider_);
    result = {ColliderResult::Type::kAttach, attached_id_.value()};
  }
  ImGui::SameLine();

  ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
  if (ImGui::Button("Delete") && collider_index_ > -1) {
    mode_ = Mode::kColliderPanelList;
    canvas_collider_.reset();
    editting_collider_ = collider_cache_[collider_index_];
    ConfirmState(Op::kColliderDelete);
    editting_collider_.reset();
    attached_id_.reset();
    collider_index_ = -1;
  }
  ImGui::PopStyleColor();

  // List Box
  if (ImGui::BeginListBox("Colliders", ImVec2(-FLT_MIN, -FLT_MIN))) {
    for (int i = 0; i < collider_cache_.size(); ++i) {
      const bool is_selected = (collider_index_ == i);
      Collider& collider = collider_cache_[i];
      std::string label = absl::StrCat(collider.name, "-", collider.id);
      if (ImGui::Selectable(label.c_str(), is_selected)) {
        collider_index_ = i;
        editting_collider_ = collider;
      }

      // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)
      if (is_selected) ImGui::SetItemDefaultFocus();
    }
    ImGui::EndListBox();
  }

  return result;
}

ColliderResult ColliderPanel::RenderDetails() {
  ColliderResult result;

  // Header information
  if (editting_collider_.has_value()) {
    ImGui::Text("ID: %s", editting_collider_->id.c_str());
    ImGui::InputText("Name", &editting_collider_->name);
  }

  RenderPolygonList();

  // Save and Reset Buttons
  ImGui::Separator();

  // We always have Save, Reset, and Detach.
  // Calculate width based on available space and spacing.
  float button_width = CalculateButtonWidth(/*num_buttons=*/3);

  // Save Button
  if (ImGui::Button("Save", ImVec2(button_width, 0))) {
    Op op = mode_ == kColliderPanelEdit ? Op::kColliderUpdate : Op::kColliderCreate;
    ConfirmState(op);

    // If we just created it, and we are attaching, emit attach event.
    if (op == Op::kColliderCreate && editting_collider_->id != kAutoGenerated) {
      result = {ColliderResult::Type::kAttach, editting_collider_->id};
      attached_id_ = editting_collider_->id;
      mode_ = kColliderPanelEdit;
      canvas_collider_ = std::make_unique<CanvasCollider>(*editting_collider_);
    }
  }
  ImGui::SameLine();

  // Detach Button (Orange)
  ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.4f, 0.0f, 1.0f));
  if (ImGui::Button("Detach", ImVec2(button_width, 0))) {
    result = {ColliderResult::Type::kDetach};
    attached_id_.reset();
    canvas_collider_.reset();
    editting_collider_.reset();
    mode_ = kColliderPanelList;
  }
  ImGui::PopStyleColor();
  ImGui::SameLine();

  // Reset Button (Red)
  ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
  if (ImGui::Button("Reset", ImVec2(button_width, 0))) {
    ConfirmState(Op::kColliderReset);
  }
  ImGui::PopStyleColor();

  return result;
}

void ColliderPanel::RenderPolygonList() {
  ImGui::Separator();
  ImGui::Text("Polygons");
  ImGui::SameLine();
  if (ImGui::Button("Add Polygon")) {
    Polygon poly;
    poly.push_back({0, 0});
    poly.push_back({50, 0});
    poly.push_back({50, 50});
    poly.push_back({0, 50});
    editting_collider_->polygons.push_back(poly);
  }

  if (!editting_collider_.has_value()) return;

  int i = 0;
  std::erase_if(editting_collider_->polygons, [&](Polygon& p) -> bool {
    ImGui::PushID(i);
    bool deleted = RenderPolygonDetails(p, i);
    ImGui::PopID();
    ++i;
    return deleted;
  });
}

bool ColliderPanel::RenderPolygonDetails(Polygon& poly, int index) {
  ImGui::Text("Polygon %d", index);
  ImGui::SameLine();
  // X button next to label
  if (ImGui::Button("X")) {
    return true;
  }

  // Vertices
  int i = 0;
  std::erase_if(poly, [&i](Vec& v) -> bool {
    bool deleted = false;
    ImGui::PushID(i);
    ++i;
    // For each vertex we should be able to edit x and y.
    ImGui::SetNextItemWidth(100);
    ImGui::InputDouble("##vec_x", &v.x);
    ImGui::SameLine();
    ImGui::SetNextItemWidth(100);
    ImGui::InputDouble("##vec_y", &v.y);
    ImGui::SameLine();
    if (ImGui::Button("X", ImVec2(30, 0))) {
      deleted = true;
    }

    ImGui::PopID();
    return deleted;
  });

  if (ImGui::Button("Add Vertex")) {
    poly.push_back({0, 0});
  }

  return false;
}

void ColliderPanel::ConfirmState(Op op) {
  if (!editting_collider_.has_value()) {
    return;
  }

  if (op == Op::kColliderDelete) {
    absl::Status result = api_->DeleteCollider(editting_collider_->id);
    if (result.ok()) {
      LOG(INFO) << "Successfully delete collider: " << editting_collider_->name << ", "
                << editting_collider_->id;
    } else {
      LOG(ERROR) << "Failed to delete collider: " << editting_collider_->name << ", "
                 << editting_collider_->id;
    }
  }

  if (op == Op::kColliderUpdate) {
    absl::Status status = api_->UpdateCollider(*editting_collider_);
    if (status.ok()) {
      LOG(INFO) << "Saved collider: " << editting_collider_->name;
    } else {
      LOG(ERROR) << "Failed to save: " << status.message();
    }
  }

  if (op == Op::kColliderCreate) {
    absl::StatusOr<std::string> id = api_->CreateCollider(*editting_collider_);
    if (id.ok()) {
      LOG(INFO) << "Saved collider: " << editting_collider_->name;
      editting_collider_->id = *id;
      RefreshColliderCache();
    } else {
      LOG(ERROR) << "Failed to save: " << id.status();
    }
  }

  if (op == Op::kColliderReset) {
    if (editting_collider_->id == kAutoGenerated) {
      editting_collider_ = {
          .id = kAutoGenerated,
          .name = "New Collider",
      };
    } else {
      absl::StatusOr<Collider*> collider = api_->GetCollider(editting_collider_->id);
      if (collider.ok()) {
        editting_collider_ = *(*collider);
        LOG(INFO) << "Reset collider: " << editting_collider_->name;
      } else {
        LOG(ERROR) << "Failed to reset: " << editting_collider_->name;
      }
    }
  }

  RefreshColliderCache();
}

}  // namespace zebes