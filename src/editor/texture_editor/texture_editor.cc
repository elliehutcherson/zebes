#include "editor/texture_editor/texture_editor.h"

#include "ImGuiFileDialog.h"
#include "SDL_render.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "common/common.h"
#include "editor/gui_interface.h"
#include "editor/imgui_scoped.h"
#include "imgui.h"

namespace zebes {

absl::StatusOr<std::unique_ptr<TextureEditor>> TextureEditor::Create(Api* api, SdlWrapper* sdl,
                                                                     GuiInterface* gui) {
  if (api == nullptr) {
    return absl::InvalidArgumentError("Api must not be null");
  }
  if (sdl == nullptr) {
    return absl::InvalidArgumentError("SdlWrapper must not be null");
  }
  if (gui == nullptr) {
    return absl::InvalidArgumentError("GUI must not be null");
  }
  return std::unique_ptr<TextureEditor>(new TextureEditor(api, sdl, gui));
}

TextureEditor::TextureEditor(Api* api, SdlWrapper* sdl, GuiInterface* gui)
    : api_(api), sdl_(sdl), gui_(gui) {
  RefreshTextures();
}

TextureEditor::~TextureEditor() {
  if (selected_texture_.sdl_texture != nullptr) {
    sdl_->DestroyTexture(reinterpret_cast<SDL_Texture*>(selected_texture_.sdl_texture));
  }
}

void TextureEditor::RefreshTextures() {
  auto result = api_->GetAllTextures();
  if (!result.ok()) {
    LOG(ERROR) << "Failed to fetch textures for importer: " << result.status();
    texture_list_.clear();
  }

  texture_list_ = *result;
  std::sort(texture_list_.begin(), texture_list_.end(),
            [](const Texture& a, const Texture& b) { return a.name < b.name; });
}

void TextureEditor::LoadPreview(const std::string& path) {
  if (!selected_texture_.id.empty()) return;

  if (selected_texture_.sdl_texture != nullptr) {
    sdl_->DestroyTexture(reinterpret_cast<SDL_Texture*>(selected_texture_.sdl_texture));
    selected_texture_.sdl_texture = nullptr;
  }

  absl::StatusOr<SDL_Texture*> texture = sdl_->CreateTexture(path);
  if (!texture.ok()) {
    LOG(ERROR) << "Failed to load preview for importer: " << texture.status();
    return;
  }

  selected_texture_.sdl_texture = *texture;
}

void TextureEditor::SelectTexture(const Texture& texture) {
  selected_texture_ = texture;
  new_texture_ = false;
  edit_name_buffer_ = texture.name;
  // +1 for null terminator
  if (edit_name_buffer_.size() <= kMaxTextureNameLength) {
    edit_name_buffer_.resize(kMaxTextureNameLength + 1, '\0');
  }
}

void TextureEditor::Render() {
  // Use tables for list and inspector
  auto table_flags = ImGuiTableFlags_Resizable | ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg;
  if (ScopedTable table = gui_->CreateScopedTable("TextureEditorTable", 2, table_flags); table) {
    gui_->TableSetupColumn("Texture List", ImGuiTableColumnFlags_WidthStretch);
    gui_->TableSetupColumn("Details", ImGuiTableColumnFlags_WidthStretch);

    gui_->TableNextRow();
    gui_->TableNextColumn();

    // Column 1: Texture List
    RenderTextureList();

    gui_->TableNextColumn();

    // Column 2: Details
    RenderTextureDetails();
  }

  // Handle File Dialog
  if (ImGuiFileDialog::Instance()->Display("TextureOpenDlg_v2")) {
    if (ImGuiFileDialog::Instance()->IsOk()) {
      std::string filePathName = ImGuiFileDialog::Instance()->GetFilePathName();
      selected_texture_.path = filePathName;
      LoadPreview(selected_texture_.path);
    }
    ImGuiFileDialog::Instance()->Close();
  }

  gui_->Separator();

  // Preview below the table
  RenderPreview();
}

void TextureEditor::RenderTextureList() {
  gui_->Text("Imported Textures");

  // Refresh list if empty (or add a refresh button)
  if (texture_list_.empty()) {
    if (gui_->Button("Refresh List")) {
      RefreshTextures();
    }
  } else {
    if (gui_->Button("Refresh List")) {
      RefreshTextures();
    }
  }

  gui_->SameLine();
  if (gui_->Button("New Texture")) {
    new_texture_ = true;
    selected_texture_ = {};
    selected_texture_ = {};
    edit_name_buffer_ = "";
    edit_name_buffer_.resize(kMaxTextureNameLength + 1, '\0');
  }

  // List textures
  ScopedListBox list_box = gui_->CreateScopedListBox(
      "##Textures", ImVec2(-FLT_MIN, 10 * gui_->GetTextLineHeightWithSpacing()));
  if (list_box) {
    for (const Texture& texture : texture_list_) {
      bool is_selected = (!new_texture_ && selected_texture_.id == texture.id);
      std::string label = texture.name_id();
      if (gui_->Selectable(label.c_str(), is_selected)) {
        SelectTexture(texture);
      }
      if (is_selected) {
        ImGui::SetItemDefaultFocus();
      }
    }
  }
}

void TextureEditor::RenderTextureDetails() {
  if (selected_texture_.id.empty() && !new_texture_) {
    gui_->TextDisabled("Select a texture to edit.");
    return;
  }

  gui_->Text("Texture Details");
  gui_->Separator();

  // ID Field
  if (new_texture_) {
    gui_->Text("ID: <Auto-Generated>");
  } else {
    // Read-only for existing
    gui_->LabelText("ID", "%s", selected_texture_.id.c_str());
  }

  // Name Field
  gui_->InputText("Name", edit_name_buffer_.data(), edit_name_buffer_.size());

  // Path Field (Read-only for now, consistent with existing logic usually)
  gui_->LabelText("Path", "%s", selected_texture_.path.c_str());

  if (new_texture_) {
    gui_->SameLine();
    if (gui_->Button("Browse...")) {
      IGFD::FileDialogConfig config;
      config.path = ".";
      ImGuiFileDialog::Instance()->OpenDialog("TextureOpenDlg_v2", "Choose File",
                                              ".png,.jpg,.jpeg,.bmp", config);
    }
  }

  gui_->Spacing();

  if (new_texture_ && gui_->Button("Create")) {
    // TODO: Implement Create Logic
    selected_texture_.name = edit_name_buffer_.c_str();
    // We assume selected_texture_.path is already set by the file dialog
    if (selected_texture_.path.empty()) {
      LOG(ERROR) << "Cannot create texture without a path.";
      return;
    }

    auto result = api_->CreateTexture(selected_texture_);
    if (!result.ok()) {
      LOG(ERROR) << "Failed to create texture: " << result.status();
      return;
    }

    RefreshTextures();
    new_texture_ = false;
    return;
  }

  if (gui_->Button("Save")) {
    selected_texture_.name = edit_name_buffer_.c_str();
    auto status = api_->UpdateTexture(selected_texture_);
    if (!status.ok()) {
      LOG(ERROR) << "Failed to update texture: " << status;
      return;
    }

    RefreshTextures();
  }
}

void TextureEditor::RenderZoom() {
  // Zoom controls
  if (gui_->Button("-")) {
    zoom_ *= 0.8f;
    if (zoom_ < 0.1f) zoom_ = 0.1f;
  }
  gui_->SameLine();
  if (gui_->Button("+")) {
    zoom_ *= 1.25f;
    if (zoom_ > 10.0f) zoom_ = 10.0f;
  }
  gui_->SameLine();
  if (gui_->Button("Reset Zoom")) {
    zoom_ = 1.0f;
  }
  gui_->SameLine();
  gui_->Text("Zoom: %.1fx", zoom_);

  int w = 0, h = 0;
  if (selected_texture_.sdl_texture) {
    SDL_QueryTexture(reinterpret_cast<SDL_Texture*>(selected_texture_.sdl_texture), nullptr,
                     nullptr, &w, &h);
  }
  float aspect = (h > 0) ? static_cast<float>(w) / static_cast<float>(h) : 1.0f;
  preview_w_ = 200.0f * zoom_;
  preview_h_ = preview_w_ / aspect;

  gui_->Text("Size: %dx%d", w, h);
}

void TextureEditor::RenderPreview() {
  RenderZoom();

  gui_->Text("Texture Preview");

  // Display the image with zoom applied
  ScopedChild child = gui_->CreateScopedChild("PreviewRegion", ImVec2(0, 400), true,
                                              ImGuiWindowFlags_HorizontalScrollbar);

  if (selected_texture_.sdl_texture == nullptr) {
    gui_->TextDisabled("No texture loaded.");
    return;
  }

  // Mouse wheel zoom when hovering over preview
  // Note: IsWindowHovered is not yet in GuiInterface, assuming ImGui::
  if (ImGui::IsWindowHovered()) {
    float wheel = ImGui::GetIO().MouseWheel;
    if (wheel != 0.0f) {
      zoom_ *= (1.0f + wheel * 0.1f);
      if (zoom_ < 0.1f) zoom_ = 0.1f;
      if (zoom_ > 10.0f) zoom_ = 10.0f;
    }
  }

  gui_->Image(reinterpret_cast<ImTextureID>(selected_texture_.sdl_texture),
              ImVec2(preview_w_, preview_h_));
}

}  // namespace zebes
