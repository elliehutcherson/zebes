#include "editor/blueprint_editor.h"

#include <algorithm>
#include <vector>

#include "absl/log/log.h"
#include "absl/status/status.h"
#include "imgui.h"

namespace zebes {

absl::StatusOr<std::unique_ptr<BlueprintEditor>> BlueprintEditor::Create(Api* api) {
  if (api == nullptr) {
    return absl::InvalidArgumentError("Api must not be null");
  }
  return std::unique_ptr<BlueprintEditor>(new BlueprintEditor(api));
}

BlueprintEditor::BlueprintEditor(Api* api) : api_(api) { RefreshBlueprintList(); }

void BlueprintEditor::RefreshBlueprintList() {
  blueprint_cache_ = api_->GetAllBlueprints();
  // Sort by name
  std::sort(blueprint_cache_.begin(), blueprint_cache_.end(),
            [](const Blueprint& a, const Blueprint& b) { return a.name < b.name; });
}

void BlueprintEditor::SelectBlueprint(const std::string& blueprint_id) {
  selected_blueprint_id_ = blueprint_id;
  absl::StatusOr<Blueprint*> blueprint = api_->GetBlueprint(blueprint_id);
  if (!blueprint.ok()) {
    LOG(ERROR) << "Failed to select blueprint: " << blueprint.status();
    selected_blueprint_id_ = "";
  }

  selected_blueprint_ = **blueprint;
  name_buffer_ = selected_blueprint_.name;
  // ensure buffer size
  if (name_buffer_.size() < 256) {
    name_buffer_.resize(256, '\0');
  }
}

void BlueprintEditor::Render() {
  if (!ImGui::BeginTable("BlueprintEditorTable", 2,
                         ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable,
                         ImGui::GetContentRegionAvail())) {
    return;
  }

  // Left Column: Controls & List
  ImGui::TableSetupColumn("Controls", ImGuiTableColumnFlags_WidthFixed, 250.0f);
  ImGui::TableSetupColumn("Editor", ImGuiTableColumnFlags_WidthStretch);
  ImGui::TableHeadersRow();

  ImGui::TableNextRow();
  ImGui::TableNextColumn();

  if (mode_ == Mode::kCreate) {
    RenderCreator();
  } else if (mode_ == Mode::kCreateState) {
    RenderCreateState();
  } else {
    RenderControls();
  }

  // Right Column: Editor / Placeholder
  ImGui::TableNextColumn();
  RenderEditor();

  ImGui::EndTable();
}

void BlueprintEditor::RenderControls() {
  // Buttons
  if (ImGui::Button("Create")) {
    mode_ = Mode::kCreate;
    creation_blueprint_ = Blueprint();
    creation_blueprint_.name = "New Blueprint";

    // Reset buffers
    name_buffer_ = creation_blueprint_.name;
    // ensure buffer size
    if (name_buffer_.size() < 256) {
      name_buffer_.resize(256, '\0');
    }

    pending_states_.clear();

    // Clear selection so we don't edit the old one while creating (optional semantics)
    selected_blueprint_id_ = "";
  }
  ImGui::SameLine();

  // Edit button - Update the current selection
  if (ImGui::Button("Edit") && !selected_blueprint_id_.empty()) {
    UpdateBlueprint();
  }

  ImGui::SameLine();
  ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1.0f));
  if (ImGui::Button("Delete") && !selected_blueprint_id_.empty()) {
    DeleteBlueprint();
  }
  ImGui::PopStyleColor();

  if (ImGui::BeginListBox("Blueprints", ImVec2(-FLT_MIN, -FLT_MIN))) {
    for (const Blueprint& bp : blueprint_cache_) {
      bool is_selected = (selected_blueprint_id_ == bp.id);
      if (ImGui::Selectable(bp.name.c_str(), is_selected)) {
        SelectBlueprint(bp.id);
      }

      if (is_selected) ImGui::SetItemDefaultFocus();
    }
    ImGui::EndListBox();
  }
}

void BlueprintEditor::RenderCreator() {
  if (ImGui::ArrowButton("Back", ImGuiDir_Left)) {
    mode_ = Mode::kList;
  }
  ImGui::SameLine();
  // "In this new create column, we should have a save button."
  if (ImGui::Button("Save")) {
    CreateBlueprint();
  }

  // "Then we need to have an input for id, which will be disabled"
  ImGui::BeginDisabled();
  ImGui::InputText("ID", (char*)"<Auto-Generated>", 17, ImGuiInputTextFlags_ReadOnly);
  ImGui::EndDisabled();

  // "and an input for name"
  ImGui::InputText("Name", name_buffer_.data(), name_buffer_.size());

  // "Below this we should have a button that says create state"
  if (ImGui::Button("Create State")) {
    mode_ = Mode::kCreateState;
    state_name_buffer_.clear();
    state_name_buffer_.resize(256, '\0');
    state_name_buffer_.clear();
    state_name_buffer_.resize(256, '\0');
    selected_sprite_index_ = -1;
    current_buffer_collider_id_.clear();
    current_collider_ = Collider();
    selected_polygon_index_ = -1;
    selected_vertex_index_ = -1;
    canvas_zoom_ = 1.0f;
    canvas_offset_ = {0, 0};
  }
}

void BlueprintEditor::RenderCreateState() {
  if (ImGui::ArrowButton("Back", ImGuiDir_Left)) {
    mode_ = Mode::kCreate;
  }
  ImGui::SameLine();

  // Save button for the STATE
  if (ImGui::Button("Save")) {
    std::string state_name = state_name_buffer_.c_str();
    if (state_name.empty()) {
      return;
    }

    PendingState new_state;
    new_state.name = state_name;

    // Get sprite ID if selected
    std::vector<Sprite> sprites = api_->GetAllSprites();
    if (selected_sprite_index_ >= 0 && selected_sprite_index_ < sprites.size()) {
      new_state.sprite_id = sprites[selected_sprite_index_].id;
    }
    new_state.collider_id = current_buffer_collider_id_;

    pending_states_.push_back(new_state);
    mode_ = Mode::kCreate;
  }

  // Name input
  ImGui::InputText("State Name", state_name_buffer_.data(), state_name_buffer_.size());

  // Dropdown for sprites
  std::vector<Sprite> sprites = api_->GetAllSprites();
  // We need a vector of const char* for ImGui
  std::vector<const char*> sprite_names;
  sprite_names.reserve(sprites.size());
  for (const Sprite& sprite : sprites) {
    sprite_names.push_back(sprite.name.c_str());
  }

  const char* current_item =
      (selected_sprite_index_ >= 0 && selected_sprite_index_ < sprites.size())
          ? sprite_names[selected_sprite_index_]
          : "None";

  if (ImGui::BeginCombo("Sprite", current_item)) {
    for (int i = 0; i < sprite_names.size(); i++) {
      bool is_selected = (selected_sprite_index_ == i);
      if (ImGui::Selectable(sprite_names[i], is_selected)) {
        selected_sprite_index_ = i;
      }
      if (is_selected) {
        ImGui::SetItemDefaultFocus();
      }
    }
    ImGui::EndCombo();
  }

  // Attach collider button
  ImGui::Separator();
  ImGui::Text("Collider");
  RenderColliderPanel();
}

void BlueprintEditor::RenderEditor() {
  if (selected_blueprint_id_.empty() && mode_ == Mode::kList) {
    ImGui::Text("Select a blue print to get started");
  } else if (mode_ == Mode::kList) {
    ImGui::Text("Selected Blueprint: %s (%s)", selected_blueprint_.name.c_str(),
                selected_blueprint_.id.c_str());

    ImGui::Separator();
    ImGui::Text("Edit Name:");
    ImGui::InputText("Name", name_buffer_.data(), name_buffer_.size());
  } else if (mode_ == Mode::kCreateState) {
    ImGui::Text("State Canvas");

    ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();
    ImVec2 canvas_sz = ImGui::GetContentRegionAvail();
    if (canvas_sz.x < 50.0f) canvas_sz.x = 50.0f;
    if (canvas_sz.y < 50.0f) canvas_sz.y = 50.0f;

    RenderCanvas(canvas_sz, canvas_p0);
  } else {
    ImGui::Text("Creating new blueprint...");
  }
}

void BlueprintEditor::CreateBlueprint() {
  Blueprint new_bp;
  new_bp.name = name_buffer_.c_str();
  if (new_bp.name.empty()) {
    new_bp.name = "New Blueprint";
  }

  // Populate states from pending_states_
  // IMPORTANT: We must ensure alphabetical order in the 'states' set,
  // and match the indices in sprite_ids map.

  // First, insert all names into the set to establish order
  for (const PendingState& ps : pending_states_) {
    new_bp.states.insert(ps.name);
  }

  // Now iterate the sorted set and populate sprite_ids based on the pending state data
  int index = 0;
  for (const std::string& state_name : new_bp.states) {
    // Find the corresponding pending state
    auto it = std::find_if(pending_states_.begin(), pending_states_.end(),
                           [&state_name](const PendingState& ps) { return ps.name == state_name; });

    if (it != pending_states_.end() && !it->sprite_id.empty()) {
      new_bp.sprite_ids[index] = it->sprite_id;
    }
    if (it != pending_states_.end() && !it->collider_id.empty()) {
      new_bp.collider_ids[index] = it->collider_id;
    }
    index++;
  }
  absl::StatusOr<std::string> id = api_->CreateBlueprint(new_bp);
  if (id.ok()) {
    RefreshBlueprintList();
    SelectBlueprint(*id);
    mode_ = Mode::kList;
  } else {
    LOG(ERROR) << "Failed to create blueprint: " << id.status();
  }
}

void BlueprintEditor::UpdateBlueprint() {
  selected_blueprint_.name = name_buffer_.c_str();
  absl::Status status = api_->UpdateBlueprint(selected_blueprint_);
  if (status.ok()) {
    RefreshBlueprintList();
    // Re-select to ensure name update in list if needed (though cache is refreshed)
    // SelectBlueprint(selected_blueprint_.id); // redundant if refreshing cache
  } else {
    LOG(ERROR) << "Failed to update blueprint: " << status;
  }
}

void BlueprintEditor::DeleteBlueprint() {
  absl::Status status = api_->DeleteBlueprint(selected_blueprint_id_);
  if (status.ok()) {
    RefreshBlueprintList();
    selected_blueprint_id_ = "";
  } else {
    LOG(ERROR) << "Failed to delete blueprint: " << status;
  }
  // Cleanup or clear state if needed
  RefreshBlueprintList();
  selected_blueprint_id_ = "";
}

void BlueprintEditor::CreateNewCollider() {
  Collider new_collider;
  absl::StatusOr<std::string> id = api_->CreateCollider(new_collider);
  if (id.ok()) {
    current_buffer_collider_id_ = *id;
    // Fetch it back to be sure? or just set it.
    new_collider.id = *id;
    current_collider_ = new_collider;
    LOG(INFO) << "Created new collider: " << *id;
  } else {
    LOG(ERROR) << "Failed to create collider: " << id.status();
  }
}

void BlueprintEditor::SaveCurrentCollider() {
  if (current_buffer_collider_id_.empty()) return;
  current_collider_.id = current_buffer_collider_id_;
  absl::Status status = api_->UpdateCollider(current_collider_);
  if (!status.ok()) {
    LOG(ERROR) << "Failed to update collider: " << status;
  }
}

void BlueprintEditor::LoadCollider(const std::string& id) {
  auto collider = api_->GetCollider(id);
  if (collider.ok()) {
    current_collider_ = **collider;
    current_buffer_collider_id_ = id;
  } else {
    LOG(ERROR) << "Failed to load collider " << id << ": " << collider.status();
    current_buffer_collider_id_ = "";
  }
}

void BlueprintEditor::RenderColliderPanel() {
  if (current_buffer_collider_id_.empty()) {
    if (ImGui::Button("Create New Collider")) {
      CreateNewCollider();
    }
    return;
  }

  ImGui::Text("ID: %s", current_buffer_collider_id_.c_str());
  ImGui::SameLine();
  if (ImGui::Button("Detach")) {
    current_buffer_collider_id_.clear();
    current_collider_ = Collider();
    selected_polygon_index_ = -1;
    selected_vertex_index_ = -1;
    return;
  }

  // Canvas Settings
  ImGui::Separator();
  ImGui::Text("Canvas Settings");
  ImGui::DragInt("Width", &canvas_width_, 1, 100, 4096);
  ImGui::DragInt("Height", &canvas_height_, 1, 100, 4096);
  ImGui::DragFloat("Zoom", &canvas_zoom_, 0.1f, 0.1f, 10.0f);

  // Polygon Management
  ImGui::Separator();
  ImGui::Text("Polygons");
  if (ImGui::Button("Add Polygon")) {
    Polygon poly;
    // Default triangle
    poly.push_back({0, 0});
    poly.push_back({50, 0});
    poly.push_back({0, 50});
    current_collider_.polygons.push_back(poly);
    selected_polygon_index_ = current_collider_.polygons.size() - 1;
    SaveCurrentCollider();
  }

  for (int i = 0; i < current_collider_.polygons.size(); ++i) {
    std::string label = "Polygon " + std::to_string(i);
    // Selectable returns true on click
    if (ImGui::Selectable(label.c_str(), selected_polygon_index_ == i)) {
      selected_polygon_index_ = i;
      selected_vertex_index_ = -1;
    }

    // Only render details if selected
    if (selected_polygon_index_ != i) continue;

    ImGui::Indent();
    if (ImGui::Button("Delete Polygon")) {
      current_collider_.polygons.erase(current_collider_.polygons.begin() + i);
      if (selected_polygon_index_ >= current_collider_.polygons.size()) {
        selected_polygon_index_ = -1;
      }
      SaveCurrentCollider();
      ImGui::Unindent();
      // Break to avoid accessing invalid iterator/index this frame
      return;
    }

    // Vertex List
    ImGui::Text("Vertices");
    Polygon& poly = current_collider_.polygons[i];
    for (int v = 0; v < poly.size(); ++v) {
      ImGui::PushID(v);
      std::string v_label = "V" + std::to_string(v);
      if (ImGui::Selectable(v_label.c_str(), selected_vertex_index_ == v, ImGuiSelectableFlags_None,
                            ImVec2(30, 0))) {
        selected_vertex_index_ = v;
      }
      ImGui::SameLine();
      float val[2] = {(float)poly[v].x, (float)poly[v].y};
      if (ImGui::DragFloat2("", val, 1.0f)) {
        poly[v].x = val[0];
        poly[v].y = val[1];
        SaveCurrentCollider();
      }
      ImGui::SameLine();
      if (ImGui::Button("X") && poly.size() > 3) {
        poly.erase(poly.begin() + v);
        if (selected_vertex_index_ >= poly.size()) selected_vertex_index_ = -1;
        SaveCurrentCollider();
      }
      ImGui::PopID();
    }
    if (ImGui::Button("Add Vertex")) {
      poly.push_back({0, 0});
      SaveCurrentCollider();
    }

    ImGui::Unindent();
  }
}

void BlueprintEditor::RenderCanvas(ImVec2 canvas_sz, ImVec2 canvas_p0) {
  ImGui::BeginChild("Canvas", canvas_sz, true,
                    ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoMove);

  ImDrawList* draw_list = ImGui::GetWindowDrawList();

  // Draw Background
  draw_list->AddRectFilled(canvas_p0, ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y),
                           IM_COL32(50, 50, 50, 255));
  draw_list->AddRect(canvas_p0, ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y),
                     IM_COL32(255, 255, 255, 255));

  // Inputs
  ImGui::SetCursorPos(ImVec2(0, 0));
  ImGui::InvisibleButton("CanvasInput", canvas_sz,
                         ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight |
                             ImGuiButtonFlags_MouseButtonMiddle);
  bool is_hovered = ImGui::IsItemHovered();
  bool is_active = ImGui::IsItemActive();

  // Zoom
  if (is_hovered && ImGui::GetIO().MouseWheel != 0.0f) {
    canvas_zoom_ += ImGui::GetIO().MouseWheel * 0.1f;
    if (canvas_zoom_ < 0.1f) canvas_zoom_ = 0.1f;
    if (canvas_zoom_ > 10.0f) canvas_zoom_ = 10.0f;
  }

  // Panning (Middle Mouse or Space+Left)
  if (is_active &&
      (ImGui::IsMouseDragging(ImGuiMouseButton_Middle) ||
       (ImGui::IsKeyDown(ImGuiKey_Space) && ImGui::IsMouseDragging(ImGuiMouseButton_Left)))) {
    canvas_offset_.x += ImGui::GetIO().MouseDelta.x;
    canvas_offset_.y += ImGui::GetIO().MouseDelta.y;
  }

  ImVec2 origin(canvas_p0.x + canvas_offset_.x, canvas_p0.y + canvas_offset_.y);

  // Coordinate conversion helpers
  auto WorldToScreen = [&](const Vec& v) -> ImVec2 {
    return ImVec2(origin.x + (float)v.x * canvas_zoom_, origin.y + (float)v.y * canvas_zoom_);
  };

  // Draw Canvas Bounds
  ImVec2 world_min = WorldToScreen({0, 0});
  ImVec2 world_max = WorldToScreen({(double)canvas_width_, (double)canvas_height_});
  draw_list->AddRect(world_min, world_max, IM_COL32(100, 100, 100, 255));

  // Draw Sprite
  std::vector<Sprite> sprites = api_->GetAllSprites();
  if (selected_sprite_index_ >= 0 && selected_sprite_index_ < sprites.size()) {
    Sprite& sprite = sprites[selected_sprite_index_];
    if (!sprite.frames.empty()) {
      SpriteFrame& frame = sprite.frames[0];
      ImVec2 p1 = WorldToScreen({0, 0});
      ImVec2 p2 = WorldToScreen({(double)frame.render_w, (double)frame.render_h});
      draw_list->AddRect(p1, p2, IM_COL32(100, 200, 100, 100));  // Green tint
    }
  }

  // Draw Colliders
  for (int i = 0; i < current_collider_.polygons.size(); ++i) {
    Polygon& poly = current_collider_.polygons[i];
    if (poly.empty()) continue;

    std::vector<ImVec2> points;
    for (const auto& v : poly) {
      points.push_back(WorldToScreen(v));
    }

    ImU32 color =
        (selected_polygon_index_ == i) ? IM_COL32(255, 0, 0, 255) : IM_COL32(200, 200, 200, 255);

    // Draw Polygon
    for (size_t k = 0; k < points.size(); ++k) {
      draw_list->AddLine(points[k], points[(k + 1) % points.size()], color, 2.0f);
    }

    // Draw Vertices and Handle Interaction
    for (size_t k = 0; k < points.size(); ++k) {
      ImVec2 p = points[k];
      draw_list->AddCircleFilled(p, 4.0f, color);

      // Interaction: Vertex Dragging
      ImVec2 mouse_pos = ImGui::GetMousePos();
      float dist_sq =
          (mouse_pos.x - p.x) * (mouse_pos.x - p.x) + (mouse_pos.y - p.y) * (mouse_pos.y - p.y);
      bool near_vertex = dist_sq < 64.0f;  // 8px radius

      if (near_vertex && is_active && ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
        selected_polygon_index_ = i;
        selected_vertex_index_ = k;
        is_dragging_ = true;
      }
    }
  }

  // Handle Dragging
  if (is_dragging_ && ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
    if (selected_polygon_index_ >= 0 &&
        selected_polygon_index_ < current_collider_.polygons.size()) {
      Polygon& poly = current_collider_.polygons[selected_polygon_index_];
      if (selected_vertex_index_ >= 0 && selected_vertex_index_ < poly.size()) {
        Vec& v = poly[selected_vertex_index_];
        v.x += ImGui::GetIO().MouseDelta.x / canvas_zoom_;
        v.y += ImGui::GetIO().MouseDelta.y / canvas_zoom_;
      }
    }
  }

  if (is_dragging_ && ImGui::IsMouseReleased(ImGuiMouseButton_Left)) {
    is_dragging_ = false;
    SaveCurrentCollider();
  }

  ImGui::EndChild();
}

}  // namespace zebes
